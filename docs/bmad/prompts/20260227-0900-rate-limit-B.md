<!-- v1.0 — 2026-02-27 -->
# Rapport — Rate Limiting /api/subscribe — Groupe B (Tests) — 20260227-0900

## Objectif

Mettre à jour la suite de tests Vitest de `/api/subscribe` pour couvrir le rate limiting ajouté par le Groupe A.
Ajouter des tests pour : 429 quand limite atteinte, headers `X-RateLimit-*` sur les réponses.

## Fichiers concernés

- `web/src/app/api/subscribe/__tests__/route.test.ts` — **À MODIFIER**

## Contexte technique

### Stack tests
- Vitest (pas Jest) — `import { vi, describe, it, expect, beforeEach } from "vitest"`
- `@testing-library/react` pour les composants, mais les tests de route sont en pur Vitest
- Mocks via `vi.mock()`

### Nouvelles dépendances du Groupe A
- `web/src/lib/rateLimit.ts` exporte `checkRateLimit(ip, limit?, windowMs?)` et `getClientIp(request)`
- L'endpoint importe ces deux fonctions

### Tests existants (à NE PAS casser)
Le fichier actuel couvre :
1. Email manquant → 400
2. Email sans "@" → 400
3. Inscription réussie avec nom → 200
4. Erreur Supabase → 500
5. Échec envoi email → 200 quand même (graceful degradation)

### Pattern de mock actuel
```typescript
vi.mock("@/lib/supabase", () => ({ getSupabase: vi.fn() }))
vi.mock("@/lib/resend", () => ({ getResend: vi.fn() }))
// Les mocks sont configurés dans beforeEach avec vi.mocked(...)
```

## Étapes

### 1. Ajouter le mock de `rateLimit`

En haut du fichier, ajouter :
```typescript
vi.mock("@/lib/rateLimit", () => ({
  checkRateLimit: vi.fn(),
  getClientIp: vi.fn(),
}))
```

### 2. Importer les mocks dans le test

```typescript
import { checkRateLimit, getClientIp } from "@/lib/rateLimit"
// ... autres imports existants
```

### 3. Configurer le comportement par défaut dans `beforeEach`

Dans le `beforeEach` existant, ajouter la config par défaut (rate limit non atteint) :
```typescript
vi.mocked(getClientIp).mockReturnValue("127.0.0.1")
vi.mocked(checkRateLimit).mockReturnValue({
  allowed: true,
  remaining: 4,
  resetAt: Date.now() + 3600000,
  limit: 5,
})
```

### 4. Nouveaux cas de test à ajouter

```typescript
describe("Rate limiting", () => {
  it("retourne 429 quand la limite est atteinte", async () => {
    vi.mocked(checkRateLimit).mockReturnValueOnce({
      allowed: false,
      remaining: 0,
      resetAt: Date.now() + 3600000,
      limit: 5,
    })

    const request = new Request("http://localhost/api/subscribe", {
      method: "POST",
      body: JSON.stringify({ email: "test@example.com" }),
      headers: { "Content-Type": "application/json" },
    })

    const response = await POST(request as NextRequest)
    expect(response.status).toBe(429)

    const body = await response.json()
    expect(body.error).toMatch(/Trop de tentatives/i)
    expect(response.headers.get("Retry-After")).toBeTruthy()
    expect(response.headers.get("X-RateLimit-Remaining")).toBe("0")
  })

  it("inclut les headers X-RateLimit-* sur une requête réussie", async () => {
    // Setup Supabase mock pour que la requête réussisse
    vi.mocked(getSupabase).mockReturnValue({
      from: vi.fn().mockReturnValue({
        upsert: vi.fn().mockResolvedValue({ error: null }),
      }),
    } as unknown as ReturnType<typeof getSupabase>)

    vi.mocked(getResend).mockReturnValue({
      emails: { send: vi.fn().mockResolvedValue({}) },
    } as unknown as ReturnType<typeof getResend>)

    const request = new Request("http://localhost/api/subscribe", {
      method: "POST",
      body: JSON.stringify({ email: "test@example.com" }),
      headers: { "Content-Type": "application/json" },
    })

    const response = await POST(request as NextRequest)
    expect(response.status).toBe(200)
    expect(response.headers.get("X-RateLimit-Limit")).toBe("5")
    expect(response.headers.get("X-RateLimit-Remaining")).toBe("4")
    expect(response.headers.get("X-RateLimit-Reset")).toBeTruthy()
  })
})
```

### 5. S'assurer que les tests existants passent toujours

Les tests existants qui testent des cas 400 (validation email) :
- Le rate limit check vient AVANT la validation email dans `route.ts`
- Donc les mocks par défaut (`allowed: true`) s'appliquent → les tests 400 continuent de fonctionner

## Contraintes

- Utiliser Vitest (`vi`) — PAS Jest (`jest`)
- Ne pas modifier les tests existants — seulement en ajouter
- Les imports doivent correspondre exactement aux exports de `rateLimit.ts` créé en Groupe A
- TypeScript strict — les mocks doivent typer correctement les retours

## Critères de validation

```bash
cd web && npm test
# Attendu : tous les tests existants passent + 2 nouveaux tests passent
# 0 fail, 0 error
```

Vérifier que la couverture des cas critiques est bien présente :
- ✅ 429 quand limite atteinte
- ✅ Headers `X-RateLimit-*` sur 200
- ✅ Header `Retry-After` sur 429

## Dépendances

**Ce groupe dépend du Groupe A** — le fichier `web/src/lib/rateLimit.ts` doit exister avant de lancer ce groupe.

## Statut

✅ Résolu — 20260227-0935

## Résolution
Rapport do : docs/bmad/do/20260227-0935-test-rate-limit.md
