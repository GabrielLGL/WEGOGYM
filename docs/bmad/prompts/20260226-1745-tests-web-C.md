<!-- v1.0 — 2026-02-26 -->
# Rapport — Tests web — Groupe C : Tests API subscribe — 20260226-1745

## Objectif
Écrire les tests automatisés pour la route API `POST /api/subscribe`.
Cette route valide l'email, enregistre en Supabase, et envoie un email via Resend.

## Fichiers concernés
- `web/src/app/api/subscribe/route.ts` — source (NE PAS MODIFIER)
- `web/src/app/api/subscribe/__tests__/route.test.ts` — créer (nouveau)

## Contexte technique
- Vitest + jsdom (configuré par Groupe A)
- Route Next.js App Router (export `POST` async function)
- Imports : `getSupabase` de `@/lib/supabase`, `getResend` de `@/lib/resend`, `WelcomeEmail` de `@/emails/welcome`
- La route retourne `NextResponse.json(...)` — tester comme une fonction pure

**Comportement de la route :**
```
Input: { email, name? }
- email manquant ou sans "@" → { error: "Email invalide" } HTTP 400
- email valide → upsert Supabase table "subscribers"
  - erreur Supabase → { error: "Erreur lors de l'inscription" } HTTP 500
  - succès Supabase → envoie email Resend (échec silencieux)
  - → { success: true } HTTP 200
```

## Étapes

### 1. Créer `web/src/app/api/subscribe/__tests__/route.test.ts`

```ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { NextRequest } from 'next/server'

// Mock Supabase
vi.mock('@/lib/supabase', () => ({
  getSupabase: vi.fn(),
}))

// Mock Resend
vi.mock('@/lib/resend', () => ({
  getResend: vi.fn(),
}))

// Mock WelcomeEmail (composant React, pas besoin de le rendre)
vi.mock('@/emails/welcome', () => ({
  WelcomeEmail: vi.fn(() => null),
}))

import { POST } from '../route'
import { getSupabase } from '@/lib/supabase'
import { getResend } from '@/lib/resend'

function makeRequest(body: Record<string, unknown>) {
  return new NextRequest('http://localhost:3000/api/subscribe', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  })
}

describe('POST /api/subscribe', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('retourne 400 si email manquant', async () => {
    const req = makeRequest({ name: 'Test' })
    const res = await POST(req)
    expect(res.status).toBe(400)
    const json = await res.json()
    expect(json.error).toBe('Email invalide')
  })

  it('retourne 400 si email sans @', async () => {
    const req = makeRequest({ email: 'invalide' })
    const res = await POST(req)
    expect(res.status).toBe(400)
    const json = await res.json()
    expect(json.error).toBe('Email invalide')
  })

  it('retourne 200 et success:true pour email valide', async () => {
    // Mock Supabase upsert OK
    const mockUpsert = vi.fn().mockResolvedValue({ error: null })
    vi.mocked(getSupabase).mockReturnValue({
      from: vi.fn().mockReturnValue({ upsert: mockUpsert }),
    } as unknown as ReturnType<typeof getSupabase>)

    // Mock Resend OK
    vi.mocked(getResend).mockReturnValue({
      emails: { send: vi.fn().mockResolvedValue({}) },
    } as unknown as ReturnType<typeof getResend>)

    const req = makeRequest({ email: 'test@example.com', name: 'Test' })
    const res = await POST(req)
    expect(res.status).toBe(200)
    const json = await res.json()
    expect(json.success).toBe(true)
  })

  it('retourne 500 si Supabase échoue', async () => {
    const mockUpsert = vi.fn().mockResolvedValue({ error: { message: 'DB error' } })
    vi.mocked(getSupabase).mockReturnValue({
      from: vi.fn().mockReturnValue({ upsert: mockUpsert }),
    } as unknown as ReturnType<typeof getSupabase>)

    const req = makeRequest({ email: 'test@example.com' })
    const res = await POST(req)
    expect(res.status).toBe(500)
    const json = await res.json()
    expect(json.error).toBe("Erreur lors de l'inscription")
  })

  it('retourne 200 même si Resend échoue (échec silencieux)', async () => {
    // Supabase OK
    const mockUpsert = vi.fn().mockResolvedValue({ error: null })
    vi.mocked(getSupabase).mockReturnValue({
      from: vi.fn().mockReturnValue({ upsert: mockUpsert }),
    } as unknown as ReturnType<typeof getSupabase>)

    // Resend KO
    vi.mocked(getResend).mockReturnValue({
      emails: { send: vi.fn().mockRejectedValue(new Error('Resend error')) },
    } as unknown as ReturnType<typeof getResend>)

    const req = makeRequest({ email: 'test@example.com' })
    const res = await POST(req)
    // L'email qui rate ne doit pas faire échouer la route
    expect(res.status).toBe(200)
    const json = await res.json()
    expect(json.success).toBe(true)
  })
})
```

### 2. Note sur les imports Next.js dans Vitest
`NextRequest` et `NextResponse` de `next/server` peuvent nécessiter une configuration
dans `vitest.config.ts` pour résoudre correctement. Si erreur d'import :
Ajouter dans `vitest.config.ts` :
```ts
test: {
  ...
  alias: {
    'next/server': 'next/dist/server/web/exports/index.js',
  }
}
```

## Contraintes
- Ne pas modifier `route.ts`
- Mocker `getSupabase` et `getResend` (ne pas appeler les vraies APIs)
- Tester le comportement observable (status HTTP + body JSON), pas l'implémentation interne

## Critères de validation
- `npm test` (depuis `web/`) → 5 tests API passent
- Les vraies APIs Supabase/Resend ne sont jamais appelées (tout est mocké)

## Dépendances
Ce groupe dépend de : **Groupe A** (Vitest doit être configuré)

## Statut
✅ Résolu — 20260226-1200

## Résolution
Rapport do : docs/bmad/do/20260226-1200-test-subscribe-route.md
