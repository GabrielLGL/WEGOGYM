<!-- v1.0 — 2026-02-26 -->
# Rapport — Architecture du thème — Groupe B — 20260226

## Objectif
Créer l'infrastructure qui rend le thème dark/light dynamique :
1. Palette `lightColors` dans le theme
2. `ThemeContext` avec Provider + hook `useTheme()`
3. Schéma v23 + User model : champ `theme_mode`

## Fichiers concernés
1. `mobile/src/theme/index.ts` — ajouter lightColors + themedColors()
2. `mobile/src/contexts/ThemeContext.tsx` — NOUVEAU fichier
3. `mobile/src/model/schema.ts` — v22 → v23, colonne `theme_mode`
4. `mobile/src/model/models/User.ts` — champ `@text('theme_mode')`

---

## 1. theme/index.ts — Ajouts

Ajouter APRÈS les exports existants (ne pas modifier ce qui existe déjà) :

```ts
// Palette light neumorphique (miroir du dark)
export const lightColors = {
  background: '#e8ecef',
  card: '#e8ecef',
  cardSecondary: '#dde2e6',
  primary: '#00cec9',
  danger: '#ff6b6b',
  success: '#00cec9',
  warning: '#e17055',
  border: '#c5cad1',
  separator: '#c5cad1',
  text: '#2d3436',
  textSecondary: '#636e72',
  placeholder: '#8a9299',
  overlay: 'rgba(20, 25, 30, 0.85)',
  bottomSheetOverlay: 'rgba(20, 25, 30, 0.45)',
  secondaryButton: '#dde2e6',
  shadow: '#b0b8c1',
  successBg: 'rgba(0, 206, 201, 0.12)',
  primaryBg: 'rgba(0, 206, 201, 0.15)',
  surfaceOverlay: 'rgba(0, 0, 0, 0.06)',
  neuShadowDark: '#b0b8c1',
  neuShadowLight: '#ffffff',
  secondaryAccent: '#6c5ce7',
}

// Ombres light neumorphiques
export const neuShadowLight = {
  elevated: {
    ...Platform.select({
      ios: {
        shadowColor: '#b0b8c1',
        shadowOffset: { width: 8, height: 8 },
        shadowOpacity: 0.9,
        shadowRadius: 16,
      },
      android: { elevation: 10 },
    }),
    borderWidth: 1,
    borderColor: '#ffffff',
  },
  elevatedSm: {
    ...Platform.select({
      ios: {
        shadowColor: '#b0b8c1',
        shadowOffset: { width: 4, height: 4 },
        shadowOpacity: 0.8,
        shadowRadius: 8,
      },
      android: { elevation: 5 },
    }),
    borderWidth: 1,
    borderColor: '#ffffff',
  },
  pressed: {
    ...Platform.select({
      ios: {
        shadowColor: '#b0b8c1',
        shadowOffset: { width: 1, height: 1 },
        shadowOpacity: 0.4,
        shadowRadius: 3,
      },
      android: { elevation: 1 },
    }),
    borderWidth: 1,
    borderColor: '#c5cad1',
  },
}

// Type union des deux palettes
export type ThemeColors = typeof colors
export type ThemeMode = 'dark' | 'light'

// Fonction utilitaire pour obtenir la palette active
export function getThemeColors(mode: ThemeMode): ThemeColors {
  return mode === 'light' ? (lightColors as ThemeColors) : colors
}

// Fonction utilitaire pour obtenir les ombres actives
export function getThemeNeuShadow(mode: ThemeMode) {
  return mode === 'light' ? neuShadowLight : neuShadow
}
```

---

## 2. mobile/src/contexts/ThemeContext.tsx — NOUVEAU FICHIER

Créer ce fichier complet :

```tsx
import React, { createContext, useContext, useState, useCallback } from 'react'
import { ThemeMode, ThemeColors, getThemeColors, getThemeNeuShadow } from '../theme'
import { database } from '../model'
import User from '../model/models/User'

interface ThemeContextValue {
  mode: ThemeMode
  colors: ThemeColors
  neuShadow: ReturnType<typeof getThemeNeuShadow>
  isDark: boolean
  toggleTheme: () => Promise<void>
  setThemeMode: (mode: ThemeMode) => Promise<void>
}

const ThemeContext = createContext<ThemeContextValue | null>(null)

interface ThemeProviderProps {
  children: React.ReactNode
  initialMode?: ThemeMode
}

export function ThemeProvider({ children, initialMode = 'dark' }: ThemeProviderProps) {
  const [mode, setMode] = useState<ThemeMode>(initialMode)

  const persistTheme = useCallback(async (newMode: ThemeMode) => {
    try {
      const users = await database.get<User>('users').query().fetch()
      const user = users[0]
      if (!user) return
      await database.write(async () => {
        await user.update(u => { u.themeMode = newMode })
      })
    } catch (error) {
      if (__DEV__) console.error('[ThemeContext] persist error:', error)
    }
  }, [])

  const toggleTheme = useCallback(async () => {
    const newMode: ThemeMode = mode === 'dark' ? 'light' : 'dark'
    setMode(newMode)
    await persistTheme(newMode)
  }, [mode, persistTheme])

  const setThemeMode = useCallback(async (newMode: ThemeMode) => {
    setMode(newMode)
    await persistTheme(newMode)
  }, [persistTheme])

  const value: ThemeContextValue = {
    mode,
    colors: getThemeColors(mode),
    neuShadow: getThemeNeuShadow(mode),
    isDark: mode === 'dark',
    toggleTheme,
    setThemeMode,
  }

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme(): ThemeContextValue {
  const ctx = useContext(ThemeContext)
  if (!ctx) throw new Error('useTheme() appelé hors ThemeProvider')
  return ctx
}

// Alias pratique pour les composants qui ont juste besoin des couleurs
export function useColors(): ThemeColors {
  return useTheme().colors
}
```

---

## 3. mobile/src/model/schema.ts — v22 → v23

Changer `version: 22` → `version: 23`.

Dans la table `users`, ajouter la colonne :
```ts
{ name: 'theme_mode', type: 'string', isOptional: true },
```

---

## 4. mobile/src/model/models/User.ts

Ajouter dans la classe User, après le champ `total_prs` :
```ts
@text('theme_mode') themeMode!: string | null
```

---

## Contraintes
- Le ThemeContext NE DOIT PAS gérer de data applicative (sessions, programmes, etc.)
- `lightColors` DOIT avoir exactement les mêmes clés que `colors` pour respecter `ThemeColors`
- La migration schema WatermelonDB est automatique (SQLite DROP/RECREATE en dev)
- En prod : les utilisateurs perdront leurs données si schema < v23 sans migration path
  → OK pour dev actuel (pas encore en prod stable)

## Critères de validation
- `npx tsc --noEmit` → zéro erreur
- `ThemeProvider` est importable depuis `contexts/ThemeContext`
- `useTheme()` et `useColors()` fonctionnent dans n'importe quel composant enfant

## Dépendances
Aucune — groupe autonome (vague 1).

## Statut
⏳ En attente
