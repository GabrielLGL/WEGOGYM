<!-- v1.0 — 2026-02-27 -->
# Rapport — Site Kore audit 2 — Groupe C — 20260227-1500
## API & Email : cache subscribers-count, domaine Resend, validation robuste

## Objectif
Améliorer 3 aspects de la couche API :

1. **Cache `subscribers-count`** : la route GET `/api/subscribers-count` interroge Supabase à chaque requête sans aucun cache. Avec ISR Next.js, on peut mettre en cache la réponse 1h sans modifier le frontend.

2. **Email Resend domain** : `route.ts` envoie depuis `"Kore <onboarding@resend.dev>"`. En production, cela arrive souvent en spam. Doit utiliser le domaine vérifié `contact@kore-app.com` (ou tout autre domaine configuré dans Resend). Utiliser une variable d'env `RESEND_FROM_EMAIL` pour que ce soit configurable sans modifier le code.

3. **Validation email robuste** : le regex `!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)` dans `subscribe/route.ts` est trop permissif (accepte `a@b.c` qui est techniquement valide mais clairement un faux email). Ajouter une validation plus stricte du TLD (minimum 2 caractères) et trim l'email.

## Fichiers concernés
- `web/src/app/api/subscribers-count/route.ts`
- `web/src/app/api/subscribe/route.ts`

## Contexte technique
- Next.js 15 App Router. Les routes API peuvent utiliser `export const revalidate = 3600` pour ISR.
- Alternativement, utiliser `NextResponse.json(data, { headers: { 'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400' } })`.
- Resend est initialisé via `getResend()` depuis `@/lib/resend`.
- Variable d'environnement à utiliser : `process.env.RESEND_FROM_EMAIL ?? "Kore <contact@kore-app.com>"`.
- TypeScript strict, pas de `any`.
- L'app est déployée sur Vercel (assumption). ISR fonctionne nativement.

## État actuel

### subscribers-count/route.ts (actuel)
```ts
export async function GET() {
  // Pas de cache — interroge Supabase à chaque requête
  const supabase = getSupabase();
  const { count, error } = await supabase
    .from("subscribers")
    .select("*", { count: "exact", head: true });
  // ...
  return NextResponse.json({ count: count ?? 0 });
}
```

### subscribe/route.ts — from email (actuel)
```ts
await resend.emails.send({
  from: "Kore <onboarding@resend.dev>",  // ← domaine dev Resend
  // ...
});
```

### subscribe/route.ts — validation email (actuel)
```ts
if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
  // trop permissif
}
```

## Étapes

### 1. Fix `subscribers-count/route.ts` — ISR cache
Ajouter en haut du fichier :
```ts
export const revalidate = 3600; // cache 1h, stale-while-revalidate implicite
```
Ou via headers de réponse si on préfère contrôler finement :
```ts
return NextResponse.json(
  { count: count ?? 0 },
  { headers: { "Cache-Control": "public, s-maxage=3600, stale-while-revalidate=86400" } }
);
```
**Recommandé** : `export const revalidate = 3600` car plus simple et compatible Edge Runtime.

### 2. Fix `subscribe/route.ts` — from email
Remplacer :
```ts
from: "Kore <onboarding@resend.dev>",
```
Par :
```ts
from: process.env.RESEND_FROM_EMAIL ?? "Kore <contact@kore-app.com>",
```

### 3. Fix `subscribe/route.ts` — validation email
Remplacer le regex par une validation plus stricte :
```ts
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/;
const trimmedEmail = typeof email === "string" ? email.trim() : "";
if (!trimmedEmail || !emailRegex.test(trimmedEmail)) {
  return NextResponse.json({ error: "Email invalide" }, { status: 400 });
}
```
Et utiliser `trimmedEmail` à la place de `email` pour l'insertion Supabase et l'envoi mail.

### 4. Fix `subscribe/route.ts` — trim name
Trim le prénom également :
```ts
const trimmedName = typeof name === "string" ? name.trim() : null;
// utiliser trimmedName à la place de name || null
```

## Contraintes
- Ne pas changer la logique métier (rate limiting, duplicate check, welcome email)
- Ne pas modifier les types de retour de l'API (frontend ne doit pas être cassé)
- TypeScript strict — pas de `any`, pas de type assertion non vérifiée
- Les variables d'env utilisées (`RESEND_FROM_EMAIL`) doivent être documentées dans un commentaire

## Critères de validation
- `npx tsc --noEmit` dans `web/` → zéro erreur
- Route `GET /api/subscribers-count` : vérifier header `Cache-Control` dans la réponse
- Route `POST /api/subscribe` avec email `"a@b.c"` → doit retourner 400 (TLD trop court)
- Route `POST /api/subscribe` avec email `"  test@example.com  "` → doit trim et accepter

## Dépendances
Aucune dépendance sur d'autres groupes.

## Statut
⏳ En attente
